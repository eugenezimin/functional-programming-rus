# Календарный план курса «Функциональное и логическое программирование»

**Общая трудоёмкость:** 52 часа (12 недель × 4 часа/неделю)

---

## Календарно-тематический план

| **Неделя** | **Тема / Модуль**                                                                                                                                                                    | **Учебная деятельность (практика)**                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                           |
| :--------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     1      | **Модуль 1. Введение в функциональное программирование (часть 1)**<br>Парадигмы программирования: императивная vs декларативная. История ФП, λ-исчисление                            | 1. Сравнить императивный и декларативный подходы на примере одной задачи (например, фильтрация списка) — написать решение на императивном языке (Python/Java) и на Haskell.<br>2. Подготовить краткий обзор (1–2 страницы) истории функционального программирования: от λ-исчисления Чёрча до современных языков (Haskell, Erlang, Scala, F#).<br>3. Изучить основные правила λ-исчисления: α-конверсия, β-редукция, η-конверсия. Выполнить ручную редукцию 3–5 λ-выражений. | [[Функциональное программирование - Модуль 1.pptx]]<br><br>code: [[MathUtils.hs]]                                                                                                                         |
|     2      | **Модуль 1. Введение в функциональное программирование (часть 2)**<br>Установка GHC, GHCi, основы синтаксиса Haskell. Базовые типы данных, функции первого порядка, pattern matching | 1. Установить GHC и GHCi (Stack или GHCup) на локальную машину. Убедиться в работоспособности, скомпилировав и запустив «Hello, World!».<br>2. Написать набор простых функций с использованием pattern matching: факториал, числа Фибоначчи, проверка палиндрома.<br>3. Исследовать базовые типы данных (`Int`, `Integer`, `Float`, `Double`, `Char`, `Bool`, `String`) и продемонстрировать различия между ними в GHCi.                                                     |                                                                                                                                                                                                           |
|     3      | **Модуль 2. Основы Haskell (часть 1)**<br>Списки и кортежи, list comprehensions. Рекурсия: хвостовая и обычная                                                                       | 1. Реализовать генерацию списков с помощью list comprehensions: простые числа до N, пифагоровы тройки, матрица смежности.<br>2. Сравнить обычную и хвостовую рекурсию на примере вычисления суммы списка — измерить потребление памяти на больших входных данных.<br>3. Решить классические рекурсивные задачи: «Ханойские башни», обход дерева, бинарный поиск.                                                                                                             | [[Функциональное программирование - Модуль 2. Часть 1. Раздел 1.pptx]]<br><br>[[Функциональное программирование - Модуль 2. Часть 1. Раздел 2, 3.pptx]]<br><br>code: [[MathUtils.hs]], [[BinaryTrees.hs]] |
|     4      | **Модуль 2. Основы Haskell (часть 2)**<br>Функции высшего порядка: `map`, `filter`, `fold`, композиция. Лабораторная работа №1                                                       | 1. Переписать итеративные алгоритмы (сортировка, поиск максимума, подсчёт элементов) с использованием `map`, `filter`, `foldl`, `foldr`.<br>2. Реализовать собственные версии `map`, `filter` и `foldl` через рекурсию.<br>3. **Лабораторная работа №1:** реализация базовых алгоритмов — сортировка слиянием, quicksort, поиск в ширину/глубину — в чисто функциональном стиле.                                                                                             | [[Функциональное программирование - Модуль 2. Часть 2.pptx]]                                                                                                                                              |
|     5      | **Модуль 3. Система типов (часть 1)**<br>Статическая типизация, вывод типов (type inference). Алгебраические типы данных (ADT), `data` и `newtype`                                   | 1. Проанализировать, как компилятор Haskell выводит типы: написать функции без аннотаций типов и проверить результат с помощью `:t` в GHCi.<br>2. Создать собственные алгебраические типы данных: `Shape` (круг, прямоугольник, треугольник) с функцией вычисления площади и `Tree a` (бинарное дерево).<br>3. Разобрать различия между `data`, `newtype` и `type` на конкретных примерах.                                                                                   |                                                                                                                                                                                                           |
|     6      | **Модуль 3. Система типов (часть 2)**<br>Параметрический полиморфизм, type variables. Классы типов: `Eq`, `Ord`, `Show`, собственные классы                                          | 1. Написать полиморфные функции (например, `swap :: (a, b) -> (b, a)`) и исследовать ограничения параметрического полиморфизма.<br>2. Реализовать экземпляры (`instance`) классов `Eq`, `Ord`, `Show` для собственных типов данных.<br>3. Создать собственный класс типов (например, `Printable` или `Serializable`) и реализовать его для нескольких типов.                                                                                                                 |                                                                                                                                                                                                           |
|     7      | **Модуль 4. Продвинутые концепции ФП (часть 1)**<br>Частичное применение и каррирование. Ленивые вычисления, бесконечные структуры данных                                            | 1. Продемонстрировать каррирование: преобразовать функции с кортежами в каррированную форму и обратно (`curry`/`uncurry`).<br>2. Создать бесконечные структуры данных: бесконечный список простых чисел (решето Эратосфена), бесконечная последовательность Фибоначчи.<br>3. Исследовать ленивые вычисления с помощью `seq`, `deepseq` и BangPatterns. Проанализировать утечки памяти (space leaks).                                                                         |                                                                                                                                                                                                           |
|     8      | **Модуль 4. Продвинутые концепции ФП (часть 2)**<br>Функторы и аппликативные функторы. Монады: `Maybe`, `Either`, `List`, `IO`                                                       | 1. Реализовать экземпляр `Functor` для собственного типа данных (например, `Tree`).<br>2. Сравнить использование `Functor`, `Applicative`и `Monad` на примере валидации данных с `Maybe` и `Either`.<br>3. Написать программу с цепочкой монадических вычислений: чтение конфигурации → парсинг → валидация → результат, используя `do`-нотацию и оператор `>>=`.                                                                                                            |                                                                                                                                                                                                           |
|     9      | **Модуль 5. Практическое программирование (часть 1)**<br>Работа с IO, чтение/запись файлов. Парсинг: библиотеки Parsec/Megaparsec                                                    | 1. Написать программу для чтения CSV-файла, обработки данных и записи результатов в новый файл.<br>2. Создать парсер арифметических выражений с помощью Megaparsec с поддержкой приоритетов операций и скобок.<br>3. Реализовать парсер простого конфигурационного формата (INI или TOML-подобного).                                                                                                                                                                         |                                                                                                                                                                                                           |
|     10     | **Модуль 5. Практическое программирование (часть 2)**<br>Тестирование: QuickCheck, HUnit. Лабораторная работа №2                                                                     | 1. Написать property-based тесты с QuickCheck для ранее реализованных функций (например, `reverse . reverse == id`, свойства сортировки).<br>2. Создать модульные тесты с HUnit для парсера из предыдущей недели.<br>3. **Лабораторная работа №2:** разработка интерпретатора простого языка выражений (арифметика + переменные + let-привязки).                                                                                                                             |                                                                                                                                                                                                           |
|     11     | **Модуль 7. Продвинутые темы**<br>Трансформеры монад, стек монад. Template Haskell, метапрограммирование. Concurrency: `forkIO`, STM, `async`                                        | 1. Построить стек монад `ReaderT Config (StateT AppState IO)` для приложения с конфигурацией и состоянием.<br>2. Изучить основы Template Haskell: написать простой splice для генерации кода (например, автоматическая сериализация).<br>3. Реализовать параллельный загрузчик веб-страниц с помощью `async` и сравнить производительность последовательного и параллельного вариантов.                                                                                      |                                                                                                                                                                                                           |
|     12     | **Модуль 8. Проектная работа**<br>Архитектура функциональных приложений. Работа над финальным проектом. Презентации и защита                                                         | 1. Подготовить архитектурную документацию для финального проекта: диаграмма модулей, описание типов данных, обоснование выбранных абстракций.<br>2. Реализовать финальный проект (один из предложенных ниже или свой вариант).<br>3. Подготовить и провести презентацию проекта (10–15 минут): демонстрация, обзор кода, ответы на вопросы.                                                                                                                                  |                                                                                                                                                                                                           |

---

## Рекомендуемые финальные проекты

1. **Интерпретатор арифметических/логических выражений** — парсинг, AST, вычисление, обработка ошибок.
2. **Система правил с backtracking** — решение головоломок (судоку, N-ферзей, криптоарифметика).
3. **Функциональный парсер конфигурационных файлов** — поддержка вложенных структур, валидация, вывод ошибок.
4. **Простая СУБД в памяти** — хранение данных, собственный query language, индексация.

---

## Список литературы и рекомендуемых источников

### Основная литература

1. **Lipovača M.** _Learn You a Haskell for Great Good!_ — No Starch Press, 2011. — Доступна бесплатно: [learnyouahaskell.com](http://learnyouahaskell.com/) _(англ.)_
2. **Душкин Р. В.** _Функциональное программирование на языке Haskell._ — М.: ДМК Пресс, 2007. _(рус.)_
3. **Bird R.** _Thinking Functionally with Haskell._ — Cambridge University Press, 2015. _(англ.)_
4. **Hutton G.** _Programming in Haskell._ — 2nd ed. — Cambridge University Press, 2016. _(англ.)_
5. **О'Салливан Б., Стюарт Д., Герцен Дж.** _Реальный мир Haskell_ (Real World Haskell). — Доступна бесплатно: [book.realworldhaskell.org](http://book.realworldhaskell.org/) _(англ., есть частичный перевод на рус.)_

### Дополнительная литература

6. **Марлоу С.** _Parallel and Concurrent Programming in Haskell._ — O'Reilly Media, 2013. _(англ.)_
7. **Allen C., Moronuki J.** _Haskell Programming from First Principles._ — 2016. — [haskellbook.com](https://haskellbook.com/) _(англ.)_
8. **Братко И.** _Программирование на языке Пролог для искусственного интеллекта._ — 4-е изд. — М.: Вильямс, 2004. _(рус.)_
9. **Пирс Б.** _Типы в языках программирования_ (Types and Programming Languages). — М.: Лямбда пресс, 2012. _(рус.)_
10. **Клини С. К.** _Математическая логика._ — М.: Мир, 1973. _(рус., для раздела о λ-исчислении)_

### Онлайн-ресурсы

11. **Haskell Wiki** — [wiki.haskell.org](https://wiki.haskell.org/) _(англ.)_
12. **Haskell MOOC** (University of Helsinki) — [haskell.mooc.fi](https://haskell.mooc.fi/) _(англ.)_
13. **Typeclassopedia** — Brent Yorgey — [wiki.haskell.org/Typeclassopedia](https://wiki.haskell.org/Typeclassopedia) _(англ.)_
14. **Школа Haskell** — [school.haskell.ru](https://www.ohaskell.guide/) _(рус.)_
15. **Stepik: Функциональное программирование на Haskell** — [stepik.org/course/75](https://stepik.org/course/75) _(рус.)_
16. **Stepik: Функциональное программирование на Haskell (часть 2)** — [stepik.org/course/693](https://stepik.org/course/693) _(рус.)_
17. **Megaparsec Tutorial** — Mark Karpov — [markkarpov.com/tutorial/megaparsec.html](https://markkarpov.com/tutorial/megaparsec.html) _(англ.)_
18. **What I Wish I Knew When Learning Haskell** — Stephen Diehl — [dev.stephendiehl.com/hask/](http://dev.stephendiehl.com/hask/) _(англ.)_